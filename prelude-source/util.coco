# Imports:
from .typevars import *  # type: ignore


# Deriving:
def derivingEqOrd(*valueConstructors: TType) -> None:
    """
    The expression
        derivingEqOrd(valueConstructor1, valueConstructor2, ...)
    is equivalent to stating that for some data type defined as
        data dataType = valueConstructor1 ... | valueConstructor2 ... | ...
    we should add
        deriving (Eq, Ord)
    """
    if TYPE_CHECKING: return

    ind = valueConstructors.index..type
    for valCon in valueConstructors:
        def valCon.__eq__(x, y) =
            type(x) is type(y) and tuple.__eq__(x, y)
        def valCon.__lt__(x, y) =
            tuple.__lt__(x, y) if type(x) is type(y) else ind(x) < ind(y)
        def valCon.__le__(x, y) =
            tuple.__le__(x, y) if type(x) is type(y) else ind(x) <= ind(y)
        def valCon.__ge__(x, y) =
            tuple.__ge__(x, y) if type(x) is type(y) else ind(x) >= ind(y)
        def valCon.__gt__(x, y) =
            tuple.__gt__(x, y) if type(x) is type(y) else ind(x) > ind(y)

def derivingEnum(*valueConstructors: TType) -> None:
    """
    The expression
        derivingEnum(valueConstructor1, valueConstructor2, ...)
    is equivalent to stating that for some data type defined as
        data dataType = valueConstructor1 ... | valueConstructor2 ... | ...
    we should add
        deriving (Enum)
    """
    if TYPE_CHECKING: return

    ind = valueConstructors.index..type
    for valCon in valueConstructors:
        def valCon.__int__(x) = ind(x)
        def valCon.__add__(x, y) =
            valueConstructors[ind(x) + y]() if isinstance(y, int) else tuple.__add__(x, y)
        def valCon.__radd__(x, y) = x + y
        def valCon.__sub__(x, y) =
            valueConstructors[ind(x) - y]() if isinstance(y, int) else tuple.__sub__(x, y)


# Monads:
def definesBind(dataType: TType) -> TType:
    """
    Decorator to declare that a data type defines __bind__
    instead of __join__. Will also create an __fmap__ method
    if none exists, though then a __pure__ method is required.
    """
    if TYPE_CHECKING: return dataType

    if not dataType `hasattr` "__fmap__":
        if not dataType `hasattr` "__pure__":
            raise TypeError("data types which define __bind__ must define either __fmap__ or __pure__")
        def dataType.__fmap__(self, func) =
            self.__bind__(x -> dataType.__pure__(func(x)))

    if dataType `hasattr` "__join__":
        raise TypeError("data types which define __bind__ cannot define __join__")
    def dataType.__join__(self) =
        self.__bind__(x -> x)

    return dataType
