# Imports:
import sys as _sys
import typing as _t
import functools as _functools




# Type variables:
_a = _t.TypeVar("_a")
_b = _t.TypeVar("_b")
_c = _t.TypeVar("_c")





# Helper functions:

## Type class helpers:
def derivingEqOrd(*valueConstructors: _t.NamedTuple) -> None:
    """
    The expression
        derivingEqOrd(valueConstructor1, valueConstructor2, ...)
    is equivalent to stating that for any data type defined as
        data dataType = valueConstructor1 ... | valueConstructor2 ... | ...
    we should add
        deriving (Eq, Ord)
    """
    ind = valueConstructors.index..type
    for valCon in valueConstructors:
        def valCon.__eq__(x, y) =
            type(x) is type(y) and tuple.__eq__(x, y)
        def valCon.__lt__(x, y) =
            tuple.__lt__(x, y) if type(x) is type(y) else ind(x) < ind(y)
        def valCon.__le__(x, y) =
            tuple.__le__(x, y) if type(x) is type(y) else ind(x) <= ind(y)
        def valCon.__ge__(x, y) =
            tuple.__ge__(x, y) if type(x) is type(y) else ind(x) >= ind(y)
        def valCon.__gt__(x, y) =
            tuple.__gt__(x, y) if type(x) is type(y) else ind(x) > ind(y)

def derivingEnum(*valueConstructors: _t.NamedTuple) -> None:
    """
    The expression
        derivingEnum(valueConstructor1, valueConstructor2, ...)
    is equivalent to stating that for any data type defined as
        data dataType = valueConstructor1 ... | valueConstructor2 ... | ...
    we should add
        deriving (Enum)
    """
    ind = valueConstructors.index..type
    for valCon in valueConstructors:
        valCon.__int__ = ind
        def valCon.__add__(self, x is int) =
            valueConstructors[ind(self) + x]()
        def valCon.__sub__(self, x is int) =
            valueConstructors[ind(self) - x]()




# Standard types, classes, and related functions:

## Basic data types:

#### Bool:
Bool = bool

not_: bool -> bool
not_ = (not)

otherwise: bool = True

#### Maybe:
class Maybe

data Nothing() from Maybe
nothing: Maybe = Nothing()

data Just(x) from Maybe

derivingEqOrd(Nothing, Just)

if TYPE_CHECKING:
    def maybe(default: _b, func: _t.Any -> _b, x: Maybe) -> _b =
        ...  # type: ignore
else:
    def maybe(default, _, Nothing()) = default

    @addpattern(maybe)
    def maybe(_, func, Just(x)) = func(x)

#### Either:
class Either

data Left(x) from Either

data Right(x) from Either

derivingEqOrd(Left, Right)

if TYPE_CHECKING:
    def either(left_func: _t.Any -> _c, right_func: _t.Any -> _c, x: Either) -> _c =
        ...  # type: ignore
else:
    def either(left_func, _, Left(x)) = left_func(x)

    @addpattern(either)
    def either(_, right_func, Right(x)) = right_func(x)

#### Ordering:
class Ordering

data LT() from Ordering
lt: Ordering = LT()

data EQ() from Ordering
eq: Ordering = EQ()

data GT() from Ordering
gt: Ordering = GT()

derivingEqOrd(LT, EQ, GT)
derivingEnum(LT, EQ, GT)

#### Char:
Char = str

#### String:
String = str


### Tuples:
fst: _t.Tuple[_a, _b] -> _a
fst = .[0]

snd: _t.Tuple[_a, _b] -> _b
snd = .[1]

def curry(func: (_a, _b) -> _c) -> _a -> _b -> _c =
    func$  # type: ignore

def uncurry(func: _a -> _b -> _c) -> (_a, _b) -> _c =
    (x, y) -> func(x)(y)



## Basic type classes:

#### Eq:
Eq = _t.Any

#### Ord:
Ord = Eq

if TYPE_CHECKING:
    def compare(x: Ord, y: Ord) -> Ordering =
        ...  # type: ignore
else:
    def compare(x, y if x == y) = eq

    @addpattern(compare)
    def compare(x, y if x < y) = lt

    @addpattern(compare)
    def compare(x, y if x > y) = gt

max: (_a, _a) -> _a
max = max  # type: ignore

min: (_a, _a) -> _a
min = min  # type: ignore

#### Enum:
Enum = _t.SupportsInt
_E = _t.TypeVar("_E", bound=Enum)

succ: _E -> _E
succ = (+)$(1)

pred: _E -> _E
pred = (-)$(?, 1)

toEnum = NotImplemented

fromEnum: Enum -> int
fromEnum = int

def enumFrom(first: _E) -> _E$[] =
    iterate(succ, first)

def enumFromThen(first: _E, second: _E) -> _E$[] =
    step = fromEnum(second) - fromEnum(first)
    iterate((+)$(step), first)

def enumFromTo(first: _E, last: _E) -> _E$[] =
    dist = fromEnum(last) - fromEnum(first)
    iterate(succ, first)$[:dist] if dist >= 0 else iterate(pred, first)$[:-dist]

def enumFromThenTo(first: _E, second: _E, last: _E) -> _E$[] =
    step = fromEnum(second) - fromEnum(first)
    iterate((+)$(step), first) |> takewhile$(-> _ <= last if step >= 0 else _ >= last)


#### Bounded:
Bounded = NotImplemented

minBound = NotImplemented

maxBound = NotImplemented



## Numbers:

### Numeric types:

#### Int:
Int = int

#### Integer:
Integer = int

#### Float:
Float = float

#### Double:
Double = float

#### Rational:
from fractions import Fraction as Rational

#### Word:
Word = Int


### Numeric type classes:

#### Num:
Num = _t.Union[int, float, Rational]
_N = _t.TypeVar("_N", bound=Num)

negate = (-)

abs: _a -> _a
abs = abs  # type: ignore

if TYPE_CHECKING:
    def signum(x) -> int =
        ...  # type: ignore
else:
    def signum(0) = 0

    @addpattern(signum)
    def signum(x if x > 0) = 1

    @addpattern(signum)
    def signum(x if x < 0) = -1

def fromInteger(x: Integer) -> Num = x

#### Real:
Real = Num

toRational: Real -> Rational
toRational = Rational

#### Integral:
Integral = int

def quot(x: int, y: int) -> int =
    divxy = x // y
    divxy + (1 if divxy < 0 and x % y != 0 else 0)

def rem(x: int, y: int) -> int =
    modxy = x % y
    modxy - (y if modxy != 0 and x // y < 0 else 0)

div: (int, int) -> int
div = (//)

mod: (int, int) -> int
mod = (%)

def quotRem(x: int, y: int) -> _t.Tuple[int, int] =
    divxy, modxy = divmod(x, y)
    divxy + (1 if modxy < 0 else 0), modxy - (y if modxy < 0 else 0)

divMod = divmod

toInteger: Integral -> Integer
toInteger = int

#### Fractional:
Fractional = Rational

recip: Fractional -> Fractional
recip = (/)$(1)

def fromRational(x: Rational) -> Fractional = x

#### Floating:
Floating = float

from math import (
    pi,
    exp,
    log,
    sqrt,
    sin,
    cos,
    tan,
    asin,
    acos,
    atan,
    sinh,
    cosh,
    tanh,
    asinh,
    acosh,
    atanh,
)

def logBase(base: Num, x: Num) -> float =
    log(x, base)

#### RealFrac:
RealFrac = Rational

def properFraction(x: Rational) -> (int, Rational) =
    floor_x = floor(x)
    floor_x + (x - floor_x)

truncate: Rational -> int
truncate = int

round: Rational -> int
round = round  # type: ignore

from math import (
    ceil as _ceil,
    floor as _floor,
)

ceiling: Rational -> int
ceiling = _ceil

floor: Rational -> int
floor = _floor

#### RealFloat:
RealFloat = float

def floatRadix(x: float) -> int = 2

floatDigits = NotImplemented

floatRange = NotImplemented

decodeFloat = NotImplemented

encodeFloat = NotImplemented

exponent = NotImplemented

significand = NotImplemented

def scaleFloat(power: int, x: float) -> float =
    x * 2**power

from math import (
    isnan as isNaN,
    isinf as isInfinite,
    atan2,
)

isDenormalized = NotImplemented

isNegativeZero = NotImplemented

isIEEE = NotImplemented


### Numeric functions:
def subtract(x, y) = x - y

def even(x: int) -> bool =
    x % 2 == 0

def odd(x: int) -> bool =
    x % 2 == 1

from fractions import gcd as gcd_

gcd: (int, int) -> int
gcd = abs..gcd_

if TYPE_CHECKING:
    def lcm(x: int, y: int) -> int =
        ...  # type: ignore
else:
    def lcm(_, 0) = 0

    @addpattern(lcm)
    def lcm(0, _) = 0

    @addpattern(lcm)
    def lcm(x, y) =
        abs_x = abs(x)
        abs_y = abs(y)
        abs_y * (abs_x // gcd_(abs_x, abs_y))

fromIntegral: Integral -> Num
fromIntegral = fromInteger

realToFrac: Real -> Fractional
realToFrac = Rational



## Monoids:
Monoid = NotImplemented

mempty = NotImplemented

mappend = NotImplemented

mconcat = NotImplemented



## Monads and functors:

#### Functor:
Functor = _t.Iterable

fmap = fmap  # type: ignore

def fmapConst(x: _a, xs: Functor) -> Functor[_a] =
    """
    fmapConst :: Functor f => (a -> b) -> f a -> f b
    fmapConst = (<$)
    """
    fmap(-> x, xs)

#### Applicative:
Applicative = _t.Collection
_A = _t.TypeVar("_A", bound=Applicative)

pure = NotImplemented

def ap(fs: Applicative[_a -> _b], xs: Applicative[_a]) -> Applicative[_b] =
    """
    ap :: Applicative f => f (a -> b) -> f a -> f b
    ap = (<*>)
    """
    fs `bind` fmap$(?, xs)

def seqAr(f1: Applicative, f2: _A) -> _A =
    """
    seqAr :: Applicative f => f a -> f b -> f b
    seqAr = (*>)
    """
    ap(fmap(x1 -> x2 -> x2, f1), f2)

def seqAl(f1: _A, f2: Applicative) -> _A =
    """
    seqAl :: Applicative f => f a -> f b -> f a
    seqAl = (<*)
    """
    ap(fmap(x1 -> x2 -> x1, f1), f2)

def liftA2(func: (_a, _b) -> _c, f1: Applicative[_a], f2: Applicative[_b]) -> Applicative[_c] =
    """Lift a binary function to actions."""
    ap(fmap(func$, f1), f2)

#### Monad:
Monad = Applicative
_M = _t.TypeVar("_M", bound=Monad)

def bind(m: Monad[_a], func: _a -> _M) -> _M =
    """
    bind :: Monad m => m a -> (a -> m b) -> m b
    bind = (>>=)
    """
    join(fmap(func, m))

def seqM(m1: Monad, m2: _M) -> _M =
    """
    seqM :: Monad m => m a -> m b -> m b
    seqM = (>>)
    """
    m1 `bind` x -> m2

return_ = NotImplemented

fail = NotImplemented

def sequence_(ms: Traversable[Monad[_a]]) -> None:
    reduce(seqM, ms)

mapM_: (_a -> Monad[_b], Traversable[_a]) -> None
mapM_ = sequence_..fmap

def bindFrom(func: _a -> Monad[_b], m: Monad[_a]) =
    """
    bindFrom :: Monad m => (a -> m b) -> m a -> m b
    bindFrom = (=<<)
    """
    m `bind` func

if TYPE_CHECKING:
    def join(m: Monad[_M]) -> _M =
        ...  # type: ignore
else:
    def join(m if len(m) == 0) = m

    @addpattern(join)
    def join(m if len(m) == 1) = m[0]

    @addpattern(join)
    def join(m) =
        """The conventional monad join operator."""
        m |> reduce$(+) |*> makedata$(type(m))

if TYPE_CHECKING:
    def do(func: -> _M, *monads: _M) -> _M =
        ...  # type: ignore
else:
    def do(func) = func()

    @addpattern(do)
    def do(func, m1, *ms) =
        """
        The call
            do(func, m1, m2, ...)
        is equivalent to the do notation
            x1 <- m1
            x2 <- m2
            ...
            func(x1, x2, ...)
        which is equivalent to the sequence of binds
            m1 `bind` x1 ->
                m2 `bind` x2 ->
                    ...
                        func(x1, x2, ...)
        """
        m1 `bind` x -> do(func$(x), *ms)



## Folds and traversals:

#### Foldable:
Foldable = _t.Sequence

foldMap = NotImplemented

def foldr(func: (_a, _b) -> _a, init: _a, xs: Foldable[_a]) -> _a =
    reduce(func, xs, init)

def foldl(func: (_a, _b) -> _a, init: _a, xs: Foldable[_a]) -> _a =
    reduce(func, reversed(xs), init)

foldr1: ((_a, _a) -> _a, Foldable[_a]) -> _a
foldr1 = reduce

def foldl1(func: (_a, _a) -> _a, xs: Foldable[_a]) -> _a =
    reduce(func, reversed(xs))

def null(xs: Foldable[_a]) -> bool = len(xs) == 0

length: Foldable -> int
length = len

def elem(e: _a, xs: Foldable[_a]) -> bool = e in xs

maximum: Foldable[_a] -> _a
maximum = max

minimum: Foldable[_a] -> _a
minimum = min

sum: Foldable[_N] -> _N
sum = sum  # type: ignore

product: Foldable[_N] -> _N
product = reduce$(*)

#### Traversable:
Traversable = Functor

def sequenceA(t: Traversable[Applicative[_a]]) -> Applicative[Traversable[_a]] =
    reduce(seqAr, t)

traverse: (_a -> Applicative[_b], Traversable[_a]) -> Applicative[Traversable[_b]]
traverse = sequenceA..fmap

def sequence(t: Traversable[_M]) -> _M =
    reduce(seqM, t)

mapM: (_a -> Monad[_b], Traversable[_a]) -> Monad[Traversable[_b]]
mapM = sequence..fmap



## Miscellaneous functions:
def id(x: _a) -> _a = x

def const(x: _a, _) -> _a = x

def dot(f: _b -> _c, g: _a -> _b) -> _a -> _c =
    """
    dot :: (b -> c) -> (a -> b) -> a -> c
    dot = (.)
    """
    f..g

def flip(func: (_a, _b) -> _c) -> (_b, _a) -> _c =
    (x, y) -> func(y, x)

def apply(f: _a -> _b, x: _a) =
    """
    apply :: (a -> b) -> a -> b
    apply = ($)
    """
    f(x)

def until(cond: _a -> bool, func: _a -> _a, x: _a) -> _a =
    if cond(x):
        return x
    until(cond, func, func(x))  # tail recursive

asTypeOf: (_a, _a) -> _a
asTypeOf = const

def error(msg: str) -> None: raise Exception(msg)

errorWithoutStackTrace = NotImplemented

undefined: _t.Any = None

def seq(x, y: _b) -> _b = y

def cbv(func: _a -> _b, arg: _a) -> _b =
    """
    cbv :: (a -> b) -> a -> b
    cbv = ($!)
    """
    func(arg)




# List operations:
map: (_a -> _b, _a$[]) -> _b$[]
map = map  # type: ignore

def append(xs: _a$[], ys: _a$[]) -> _a$[] =
    """
    append :: [a] -> [a] -> [a]
    append = (++)
    """
    (::)(xs, ys)

filter: (_a -> bool, _a$[]) -> _a$[]
filter = filter  # type: ignore

head: _a$[] -> _a
head = .$[0]

last: _a$[] -> _a
last = .$[-1]

tail: _a$[] -> _a$[]
tail = .$[1:]  # type: ignore

init: _a$[] -> _a$[]
init = .$[:-1]  # type: ignore

def index(xs: _a$[], i: int) -> _a =
    xs$[i]

reverse: _a[] -> _a[]
reverse = reversed



## Special folds:
and_: Foldable[bool] -> bool
and_ = all  # type: ignore

or_: Foldable[bool] -> bool
or_ = any  # type: ignore

any: ((_a -> bool), Foldable[_a]) -> bool
any = or_..map

all: ((_a -> bool), Foldable[_a]) -> bool
all = and_..map

concat: Foldable[_a$[]] -> _a$[]
concat = reduce$(::)  # type: ignore

concatMap: ((_a -> _b$[]), Foldable[_a]) -> _b$[]
concatMap = concat..map



## Building lists:

### Scans:
def scanl(func: (_a, _b) -> _a, init: _a, xs: _b[]) -> _a$[] =
    scan(func, reversed(xs), init)

def scanl1(func: (_a, _a) -> _a, xs: _a[]) -> _a$[] =
    scan(func, reversed(xs))

def scanr(func: (_a, _b) -> _a, init: _a, xs: _b$[]) -> _a$[] =
    scan(func, xs, init)

scanr1 = scan

### Infinite lists:
@recursive_iterator
def iterate(func: _a -> _a, x: _a) -> _a$[] =
    [x] :: iterate(func, func(x))

@recursive_iterator
def repeat(x: _a) -> _a$[] =
    [x] :: repeat(x)

def replicate(n: int, x: _a) -> _a$[] =
    repeat(x)$[:n]

if TYPE_CHECKING:
    def cycle(xs: _a$[]) -> _a$[] =
        ...  # type: ignore
else:
    @recursive_iterator
    def cycle(xs if len(xs) > 0) =
        xs :: cycle(xs)



## Sublists:
def take(n: int, xs: _a$[]) -> _a$[] =
    xs$[:n]

def drop(n: int, xs: _a$[]) -> _a$[] =
    xs$[n:]

def splitAt(n: int, xs: _a$[]) -> _t.Tuple[_a$[], _a$[]] =
    reit = reiterable(xs)
    reit$[:n], reit$[n:]

takeWhile = takewhile

dropWhile = dropwhile

if TYPE_CHECKING:
    def span(cond: _a -> bool, xs: _a[]) -> _a[] =
        ...  # type: ignore
else:
    def span(_, []) = ([], [])

    @addpattern(span)
    def span(cond, [x] + t as xs if cond(x)) =
        ys, zs = span(cond, t)
        ([x] + ys, zs)

    @addpattern(span)
    def span(cond, xs) =
        ([], xs)

def break_(cond: _a -> bool, xs: _a[]) -> _a[] =
    span((not)..cond, xs)



## Searching lists:
def notElem(e: _a, xs: _a[]) -> bool =
    e not in xs

def lookup(key: _a, assocs: _t.Tuple[_a, _b]$[]) -> Maybe:
    try:
        return (
            assocs
            |> dropwhile$(pair -> pair[0] != key)
            |> .$[0]
            |> .[1]
            |> Just
        )
    except StopIteration:
        return nothing



## Zipping and unzipping lists:
zip = zip3 = zip  # type: ignore

def zipWith(func: -> _a, *iters) -> _a$[] =
    starmap(func, zip(*iters))

zipWith3 = zipWith

def unzip(xs: _a$[]$[]) -> _a$[]$[] =
    zip(*xs)

unzip3 = unzip



## Functions on strings:
lines: str -> str[]
lines = .split("\n")  # type: ignore

words: str -> str[]
words = .split()  # type: ignore

unlines: str[] -> str
unlines = "\n".join

unwords: str[] -> str
unwords = " ".join




# Converting to and from String:

## Converting to String:
show = str




# Basic input and output:

## Simple I/O operations:

### Output functions:
putStr: str -> None = print$(end="")
putChar = putStr

putStrLn = print


### Input functions:
getChar: () -> str = _sys.stdin.read$(1)

getLine = input

getContents: () -> str = _sys.stdin.read

def interact(func: str -> str) -> None:
    while True:
        input() |> func |> print


### Files:
FilePath = str

def readFile(fpath: str) -> str:
    with open(fpath, "r+") as f:
        return f.read()

def writeFile(fpath: str, fstr: str) -> None:
    with open(fpath, "w+") as f:
        f.write(fstr)  # type: ignore

def appendFile(fpath: str, fstr: str) -> None:
    with open(fpath, "a+") as f:
        f.write(fstr)  # type: ignore



## Exception handling:
IOError = IOError  # type: ignore

def ioError() -> None: raise IOError()

def userError(msg: str) -> None: raise IOError(msg)
