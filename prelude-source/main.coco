# Helpers:

#### Imports:
import sys
import fractions as _fractions
import math as _math
import ast as _ast

from prelude.util import *  # type: ignore

#### Untyped built-ins:
_max: -> T.Any = max
_min: -> T.Any = min
_zip: -> T.Any = zip
_abs: -> T.Any = abs
_round: -> T.Any = round
_fmap: -> T.Any = fmap
_reduce: -> T.Any = reduce
_all: -> T.Any = all
_any: -> T.Any = any
_map: -> T.Any = map
_filter: -> T.Any = filter
_int: -> T.Any = int
_sum: -> T.Any = sum
_reversed: -> T.Any = reversed
_print: -> T.Any = print
_ceil: -> T.Any = _math.ceil
_floor: -> T.Any = _math.floor




# Standard types, classes, and related functions:

## Basic data types:

#### Bool:
Bool = bool

not_: bool -> bool
not_ = (not)

otherwise: bool = True

#### Maybe:
class Maybe:
    @staticmethod
    def __pure__(x: Ta) -> Maybe = Just(x)

    @staticmethod
    def __fail__(msg: str) -> Maybe = nothing

    @staticmethod
    def __mempty__() -> Maybe = nothing

data Nothing() from Maybe
nothing: Maybe = Nothing()

data Just(x) from Maybe

derivingOrd(Nothing, Just)

if TYPE_CHECKING:
    def maybe(default: Tb, func: Ta -> Tb, x: Maybe) -> Tb =
        ...  # type: ignore
else:
    match def maybe(default, _, Nothing()) = default
    addpattern def maybe(_, func, Just(x)) = func(x)

#### Either:
class Either:
    @staticmethod
    def __pure__(x: Ta) -> Either = Right(x)

    @staticmethod
    def __fail__(msg: str) -> Either = Left(msg)

data Left(x) from Either:
    @staticmethod
    def __bool__() -> bool = False

    def __fmap__(self, func: Ta -> Tb) -> Either = self

data Right(x) from Either

derivingOrd(Left, Right)

if TYPE_CHECKING:
    def either(left_func: Ta -> Tc, right_func: Tb -> Tc, x: Either) -> Tc =
        ...  # type: ignore
else:
    match def either(left_func, _, Left(x)) = left_func(x)
    addpattern def either(_, right_func, Right(x)) = right_func(x)

#### Ordering:
class Ordering:
    @staticmethod
    def __mempty__() -> Ordering = eq

data LT() from Ordering:
    @staticmethod
    def __bool__() -> bool = True

data EQ() from Ordering

data GT() from Ordering:
    @staticmethod
    def __bool__() -> bool = True

derivingOrd(LT, EQ, GT)
derivingBoundedEnum(LT, EQ, GT)

lt: Ordering = LT()
eq: Ordering = EQ()
gt: Ordering = GT()

#### Char:
Char = T.NewType("Char", str)

#### String:
String = str


### Tuples:
fst: T.Tuple[Ta, Tb] -> Ta
fst = .[0]

snd: T.Tuple[Ta, Tb] -> Tb
snd = .[1]

def curry(func: (Ta, Tb) -> Tc) -> Ta -> Tb -> Tc =
    func$

def uncurry(func: Ta -> Tb -> Tc) -> (Ta, Tb) -> Tc =
    (x, y) -> func(x)(y)



## Basic type classes:

#### Eq:
Eq = object

#### Ord:
Ord = Eq
TOrd = T.TypeVar("TOrd", bound=Ord)

if TYPE_CHECKING:
    def compare(x: Ord, y: Ord) -> Ordering =
        ...  # type: ignore
else:
    match def compare(x, y if x == y) = eq
    addpattern def compare(x, y if x < y) = lt
    addpattern def compare(x, y if x > y) = gt

max: (TOrd, TOrd) -> TOrd
max = _max

min: (TOrd, TOrd) -> TOrd
min = _min

#### Enum:
Enum = Ord
TEnum = T.TypeVar("TEnum", bound=Enum)

succ: TEnum -> TEnum
succ = (+)$(1)

pred: TEnum -> TEnum
pred = (-)$(?, 1)

toEnum = NotImplemented

fromEnum: Enum -> int
fromEnum = _int

def enumFrom(first: TEnum) -> TEnum$[] =
    iterate(succ, first)

def enumFromThen(first: TEnum, second: TEnum) -> TEnum$[] =
    step = fromEnum(second) - fromEnum(first)
    iterate((+)$(step), first) if step >= 0 else ()  # type: ignore

def enumFromTo(first: TEnum, last: TEnum) -> TEnum$[] =
    dist = fromEnum(last) - fromEnum(first)
    iterate(succ, first)$[:dist+1] if dist >= 0 else ()  # type: ignore

def enumFromThenTo(first: TEnum, second: TEnum, last: TEnum) -> TEnum$[] =
    step = fromEnum(second) - fromEnum(first)
    dist = fromEnum(last) - fromEnum(first)
    steps = dist/step if step != 0 else 0
    if steps < 0:
        return ()
    counter = iterate((+)$(step), first)
    counter$[:int(steps)+1] if steps != 0 else counter


#### Bounded:
Bounded = T.Union[bool, T.Iterable]
TBounded = T.TypeVar("TBounded", bound=Bounded)

def minBound(b: TBounded) -> TBounded =
    """
    -- minBound is overridden by the __minBound__ method
    -- the default implementation recursively calls fmap (__fmap__) with minBound
    """
    # Check if bool
    if b `isinstance` bool:
        return False  # type: ignore

    # Check if overridden
    if b `hasattr` "__minBound__":
        return b.__minBound__()

    # Default implementation
    fmap(minBound, b)

def maxBound(b: TBounded) -> TBounded =
    """
    -- maxBound is overridden by the __maxBound__ method
    -- the default implementation recursively calls fmap (__fmap__) with maxBound
    """
    # Check if bool
    if b `isinstance` bool:
        return True  # type: ignore

    # Check if overridden
    if b `hasattr` "__maxBound__":
        return b.__maxBound__()

    # Default implementation
    fmap(maxBound, b)



## Numbers:

### Numeric types:

#### Int:
Int = int

#### Integer:
Integer = int

#### Float:
Float = float

#### Double:
Double = float

#### Rational:
Rational = _fractions.Fraction

def over(x, y) =
    """
    import Data.Ratio
    over :: Integer -> Integer -> Rational
    over = (%)
    """
    Rational(x, y)

#### Word:
Word = Int


### Numeric type classes:

#### Num:
Num = T.Union[int, float, Rational]
TNum = T.TypeVar("TNum", bound=Num)

negate: TNum -> TNum
negate = (-)

abs: TNum -> TNum
abs = _abs

if TYPE_CHECKING:
    def signum(x: Num) -> int =
        ...  # type: ignore
else:
    match def signum(0) = 0
    addpattern def signum(x if x > 0) = 1
    addpattern def signum(x if x < 0) = -1

def fromInteger(x: Integer) -> Num = x

#### Real:
Real = Num

if TYPE_CHECKING:
    def toRational(real: Real) -> Rational =
        ...  # type: ignore
else:
    match def toRational(real is float) =
        Rational.from_float(real)
    addpattern def toRational(real) =
        Rational(real)

#### Integral:
Integral = int

def quot(x: int, y: int) -> int =
    divxy = x // y
    divxy + (1 if divxy < 0 and x % y != 0 else 0)

def rem(x: int, y: int) -> int =
    modxy = x % y
    modxy - (y if modxy != 0 and x // y < 0 else 0)

div: (int, int) -> int
div = (//)

mod: (int, int) -> int
mod = (%)

def quotRem(x: int, y: int) -> T.Tuple[int, int] =
    divxy, modxy = divmod(x, y)
    adj = 1 if divxy < 0 and modxy != 0 else 0
    divxy + adj, modxy - y*adj

divMod = divmod

toInteger: Integral -> Integer
toInteger = _int

#### Fractional:
Fractional = Rational

recip: Fractional -> Fractional
recip = (/)$(1)

def fromRational(x: Rational) -> Fractional = x

#### Floating:
Floating = float

from math import (
    pi,
    exp,
    log,
    sqrt,
    sin,
    cos,
    tan,
    asin,
    acos,
    atan,
    sinh,
    cosh,
    tanh,
    asinh,
    acosh,
    atanh,
)

def logBase(base: float, x: float) -> float =
    log(x, base)

#### RealFrac:
RealFrac = Rational

def properFraction(x: RealFrac) -> T.Tuple[int, RealFrac] =
    floor_x = floor(x)
    floor_x, x - floor_x

truncate: RealFrac -> int
truncate = _int

round: RealFrac -> int
round = _round

ceiling: RealFrac -> int
ceiling = _ceil

floor: RealFrac -> int
floor = _floor

#### RealFloat:
RealFloat = float

def floatRadix(x: float) -> int = 2

def floatDigits(x: float) -> int = 53

def floatRange(x: float) -> T.Tuple[int, int] = (-1021, 1024)

decodeFloat = NotImplemented

encodeFloat = NotImplemented

exponent = NotImplemented

significand = NotImplemented

def scaleFloat(power: int, x: float) -> float =
    x * 2**power

from math import (
    isnan as isNaN,
    isinf as isInfinite,
    atan2,
)

isDenormalized = NotImplemented

def isNegativeZero(x: float) -> bool =
    x == 0 and str(x).startswith("-")

def isIEEE(x: float) -> bool = True


### Numeric functions:
def subtract(x, y) =
    y - x

def even(x: int) -> bool =
    x % 2 == 0

def odd(x: int) -> bool =
    x % 2 == 1

gcd: (int, int) -> int
gcd = abs.._fractions.gcd

if TYPE_CHECKING:
    def lcm(x: int, y: int) -> int =
        ...  # type: ignore
else:
    match def lcm(_, 0) = 0
    addpattern def lcm(0, _) = 0
    addpattern def lcm(x, y) =
        abs(y) * (abs(x) // gcd(x, y))

fromIntegral: Integral -> Num
fromIntegral = fromInteger

realToFrac: Real -> Fractional
realToFrac = toRational



## Monoids:
Monoid = T.Iterable
TMonoid = T.TypeVar("TMonoid", bound=Monoid)

data Mempty():
    """
    -- mempty is overridden by the __mempty__ method
    """
    @staticmethod
    def mempty_as(M: TMonoid) -> TMonoid =
        if M `hasattr` "__mempty__":
            return M.__mempty__()  # type: ignore
        makedata(type(M))

mempty: T.Any = Mempty()

def mappend(x: TMonoid, y: TMonoid) -> TMonoid =
    """
    -- mappend is overridden by the __mappend__ method
    -- you may also want to define a __mempty__ method
    -- the default implementation identifies non-identities using __bool__
    """
    # Resolve memptys
    x = x `asTypeOf` y
    y = y `asTypeOf` x

    # Check if overridden
    if x `hasattr` "__mappend__":
        return x.__mappend__(y)  # type: ignore

    # Default implementation
    if not x:
        return y
    if not y:
        return x
    if x `isinstance` tuple and y `isinstance` tuple:
        return zipWith(mappend, x, y) |*> makedata$(type(x))
    (::)(x, y) |*> makedata$(type(x))

def mconcat(ms: TMonoid[]) -> TMonoid =
    foldr(mappend, mempty, ms)



## Monads and functors:

#### Functor:
Functor = T.Iterable

fmap: (Ta -> Tb, Functor[Ta]) -> Functor[Tb]  # type: ignore
fmap = _fmap

def fmapConst(x: Ta, xs: Functor) -> Functor[Ta] =
    """
    fmapConst :: Functor f => (a -> b) -> f a -> f b
    fmapConst = (<$)
    """
    _fmap(_ -> x, xs)

#### Applicative:
Applicative = Functor
TApp = T.TypeVar("TApp", bound=Applicative)

if TYPE_CHECKING:
    def pure(x: Ta) -> T.Any =
        ...  # type: ignore
else:
    data pure(val):
        """
        return_ = return
        -- pure/return is overridden by the __pure__ method
        """
        def __join__(self) -> T.Any = self.val

        def pure_as(self, M: TApp) -> TApp =
            if M `hasattr` "__pure__":
                return M.__pure__(self.val)  # type: ignore
            makedata(type(M), self.val)

def ap(fs: Applicative[Ta -> Tb], xs: Applicative[Ta]) -> Applicative[Tb] =
    """
    ap :: Applicative f => f (a -> b) -> f a -> f b
    ap = (<*>)
    -- ap is overridden by the __ap__ method
    -- you may also want to define a __pure__ method
    -- the default implementation uses join (__join__) and fmap (__fmap__)
    """
    # Resolve pures
    fs = fs `asTypeOf` xs  # type: ignore
    xs = xs `asTypeOf` fs  # type: ignore

    # Check if overridden
    if fs `hasattr` "__ap__":
        return fs.__ap__(xs)  # type: ignore

    # Default implementation
    fs `bind` f -> _fmap(f, xs)

def seqAr(f1: Applicative, f2: TApp) -> TApp =
    """
    seqAr :: Applicative f => f a -> f b -> f b
    seqAr = (*>)
    """
    _fmap(x1 -> x2 -> x2, f1) `ap` f2

def seqAl(f1: TApp, f2: Applicative) -> TApp =
    """
    seqAl :: Applicative f => f a -> f b -> f a
    seqAl = (<*)
    """
    _fmap(x1 -> x2 -> x1, f1) `ap` f2

def liftA2(func: (Ta, Tb) -> Tc) -> (Applicative[Ta], Applicative[Tb]) -> Applicative[Tc] =
    """
    import Control.Applicative
    liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
    """
    (f1, f2) -> _fmap(func$, f1) `ap` f2

#### Monad:
Monad = Applicative
TMonad = T.TypeVar("TMonad", bound=Monad)

def bind(m: Monad[Ta], func: Ta -> TMonad) -> TMonad =
    """
    bind :: Monad m => m a -> (a -> m b) -> m b
    bind = (>>=)
    -- bind is overridden by overriding fmap (__fmap__) and join (__join__)
    """
    join(_fmap(func, m))

def seqM(m1: Monad, m2: TMonad) -> TMonad =
    """
    seqM :: Monad m => m a -> m b -> m b
    seqM = (>>)
    """
    m1 `bind` x -> m2

return_ = pure

if TYPE_CHECKING:
    def fail(msg: str) -> T.Any =
        ...  # type: ignore
else:
    data fail(msg: str):
        """
        -- fail is overridden by the __fail__ method
        """
        @staticmethod
        def __bool__() -> bool = False

        def __fmap__(self, func: Ta -> Tb) -> T.Any = self

        def fail_as(self, M: TMonad) -> TMonad =
            if M `hasattr` "__fail__":
                return M.__fail__(self.msg)  # type: ignore
            makedata(type(M))

# sequence_ and mapM_ defined in Foldable

def bindFrom(func: Ta -> TMonad, m: Monad[Ta]) -> TMonad =
    """
    bindFrom :: Monad m => (a -> m b) -> m a -> m b
    bindFrom = (=<<)
    """
    m `bind` func

def join(ms: Monad[TMonad]) -> TMonad =
    """
    import Control.Monad
    join :: Monad m => m (m a) -> m a
    -- join is overridden by the __join__ method
    -- you may also want to define __pure__ and __fail__ methods (pure = return)
    -- the default implementation identifies non-failures using __bool__
    """
    # Resolve ms being pure or fail
    ms = reduce((ms, m) -> ms `asTypeOf` m, ms, ms)

    # Resolve pures and fails inside of ms
    ms = ms |> fmap$(m -> m `asTypeOf` ms)  # type: ignore

    # Check if overridden
    if ms `hasattr` "__join__":
        return ms.__join__()  # type: ignore

    # Default implementation
    if not ms:
        return ms  # type: ignore
    vals = []  # type: ignore
    fallback = ms
    for m in ms:
        if m:
            vals.extend(m)
        else:
            fallback = m
    if not vals:
        return fallback  # type: ignore
    makedata(type(ms), *vals)

if TYPE_CHECKING:
    def do(monads: TMonad[], func: -> TMonad) -> TMonad =
        ...  # type: ignore
else:
    match def do([], func) = func()
    addpattern def do([m] + ms, func) =
        """
        The call
            do([m1, m2, ...], func)
        is equivalent to the sequence of binds
            m1 `bind` x1 ->
                m2 `bind` x2 ->
                    ...
                        func(x1, x2, ...)
        which is meant to mimic the do notation
            x1 <- m1
            x2 <- m2
            ...
            func(x1, x2, ...)
        or do can also be used as a decorator such that
            @do$([m1, m2, ...])
            def func(x1, x2, ...) =
                ...
        also does the same thing.
        """
        m `bind` x -> do(ms, func$(x))



## Folds and traversals:

#### Foldable:
Foldable = T.Sequence

def sequence_(ms: Foldable[Monad]) -> Monad =
    do(ms, (*xs) -> pure(()))

mapM_: (Ta -> Monad, Foldable[Ta]) -> Monad
mapM_ = sequence_..fmap

def foldMap(func: Ta -> TMonoid, xs: Foldable[Ta]) -> TMonoid =
    mconcat(map(func, xs))

def foldl(func: (Tb, Ta) -> Tb, init: Tb, xs: Foldable[Ta]) -> Tb =
    _reduce(func, xs, init)

def foldr(func: (Ta, Tb) -> Tb, init: Tb, xs: Foldable[Ta]) -> Tb =
    _reduce((x, y) -> func(y, x), reversed(xs), init)

foldl1: ((Ta, Ta) -> Ta, Foldable[Ta]) -> Ta
foldl1 = reduce

def foldr1(func: (Ta, Ta) -> Ta, xs: Foldable[Ta]) -> Ta =
    reduce((x, y) -> func(y, x), reversed(xs))

def null(xs: Foldable[Ta]) -> bool =
    len(xs) == 0

length: Foldable -> int
length = len

def elem(e: Ta, xs: Foldable[Ta]) -> bool =
    e in xs

maximum: Foldable[TOrd] -> TOrd
maximum = _max

minimum: Foldable[TOrd] -> TOrd
minimum = _min

sum: Foldable[TNum] -> TNum
sum = _sum

product: Foldable[TNum] -> TNum
product = reduce$(*)

#### Traversable:
Traversable = T.Iterable

def _snoc(xs: Ta$[], x: Ta) -> Ta$[] =
    (::)(xs, (x,))

def sequenceA(fs: Traversable[Applicative[Ta]]) -> Applicative[Traversable[Ta]] =
    reduce(liftA2(_snoc), fs, pure(())) |> fmap$(xs -> makedata(type(fs), *xs))

traverse: (Ta -> Applicative[Tb], Traversable[Ta]) -> Applicative[Traversable[Tb]]
traverse = sequenceA..fmap

sequence: Traversable[Monad[Ta]] -> Monad[Traversable[Ta]]
sequence = sequenceA

mapM: (Ta -> Monad[Tb], Traversable[Ta]) -> Monad[Traversable[Tb]]
mapM = traverse



## Miscellaneous functions:
def id(x: Ta) -> Ta = x

def const(x: Ta) -> Tb -> Ta =
    y -> x

def dot(f: Tb -> Tc, g: Ta -> Tb) -> Ta -> Tc =
    """
    dot :: (b -> c) -> (a -> b) -> a -> c
    dot = (.)
    """
    f..g

def flip(func: (Ta, Tb) -> Tc) -> (Tb, Ta) -> Tc =
    (x, y) -> func(y, x)

def apply(func: Ta -> Tb, arg: Ta) -> Tb =
    """
    apply :: (a -> b) -> a -> b
    apply = ($)
    """
    func(arg)

def until(cond: Ta -> bool, func: Ta -> Ta, x: Ta) -> Ta =
    if cond(x):
        return x
    until(cond, func, func(x))  # tail recursive

def asTypeOf(x: Ta, y: Ta) -> Ta:
    """
    -- use asTypeOf to resolve pure, fail, and mempty to the correct type
    -- set asTypeOf.RECURSION_LIMIT to control recursive resolution
    """
    if TYPE_CHECKING: return x

    if not y `isinstance` (pure, fail, Mempty):
        for i in count() |> takewhile$(i -> i < asTypeOf.RECURSION_LIMIT):
            if x `isinstance` pure:
                x = x.pure_as(y)
            elif x `isinstance` fail:
                x = x.fail_as(y)
            elif x `isinstance` Mempty:
                x = x.mempty_as(y)
            else:
                break
    return x

asTypeOf.RECURSION_LIMIT = 3  # type: ignore

def error(msg: str) -> None:
    raise Exception(msg)

def errorWithoutStackTrace(msg: str) -> None:
    raise Exception(msg) from None

undefined: T.Any = None

def seq(x: Ta, y: Tb) -> Tb = y

def cbv(func: Ta -> Tb, arg: Ta) -> Tb =
    """
    cbv :: (a -> b) -> a -> b
    cbv = ($!)
    """
    func(arg)




# List operations:
def cons(x: Ta, xs: Ta$[]) -> Ta$[] =
    """
    cons :: a -> [a] -> [a]
    cons = (:)
    """
    (::)([x], xs)

map: (Ta -> Tb, Ta$[]) -> Tb$[]
map = _map

def chain(xs: Ta$[], ys: Ta$[]) -> Ta$[] =
    """
    chain :: [a] -> [a] -> [a]
    chain = (++)
    """
    (::)(xs, ys)

filter: (Ta -> bool, Ta$[]) -> Ta$[]
filter = _filter

head: Ta$[] -> Ta
head = .$[0]

last: Ta$[] -> Ta
last = .$[-1]

tail: Ta$[] -> Ta$[]
tail = .$[1:]  # type: ignore

init: Ta$[] -> Ta$[]
init = .$[:-1]  # type: ignore

def at(xs: Ta$[], i: int) -> Ta =
    """
    at :: [a] -> Int -> a
    at = (!!)
    """
    xs$[i]

reverse: Ta[] -> Ta[]
reverse = _reversed



## Special folds:
and_: Foldable[bool] -> bool
and_ = _all

or_: Foldable[bool] -> bool
or_ = _any

any: ((Ta -> bool), Foldable[Ta]) -> bool
any = or_..map

all: ((Ta -> bool), Foldable[Ta]) -> bool
all = and_..map

def concat(xs: Foldable[Ta$[]]) -> Ta$[] =
    _reduce((::), xs, ())

concatMap: (Ta -> Tb$[], Foldable[Ta]) -> Tb$[]
concatMap = concat..map



## Building lists:

### Scans:
def scanl(func: (Ta, Tb) -> Ta, init: Ta, xs: Tb$[]) -> Ta$[] =
    scan(func, xs, init)

scanl1: ((Ta, Ta) -> Ta, Ta$[]) -> Ta$[]
scanl1 = scan

def scanr(func: (Ta, Tb) -> Ta, init: Ta, xs: Tb[]) -> Ta$[] =
    scan(func, reversed(xs), init)$[::-1]

def scanr1(func: (Ta, Ta) -> Ta, xs: Ta[]) -> Ta$[] =
    scan(func, reversed(xs))$[::-1]

### Infinite lists:
@recursive_iterator
def iterate(func: Ta -> Ta, x: Ta) -> Ta$[] =
    [x] :: iterate(func, func(x))

@recursive_iterator
def repeat(x: Ta) -> Ta$[] =
    [x] :: repeat(x)

def replicate(n: int, x: Ta) -> Ta$[] =
    repeat(x)$[:n]

if TYPE_CHECKING:
    def cycle(xs: Ta[]) -> Ta$[] =
        ...  # type: ignore
else:
    @recursive_iterator
    def cycle(xs if len(xs) > 0) =
        xs :: cycle(xs)



## Sublists:
def take(n: int, xs: Ta$[]) -> Ta$[] =
    xs$[:n]

def drop(n: int, xs: Ta$[]) -> Ta$[] =
    xs$[n:]

def splitAt(n: int, xs: Ta$[]) -> T.Tuple[Ta$[], Ta$[]] =
    reit = reiterable(xs)
    reit$[:n], reit$[n:]

takeWhile: (Ta -> bool, Ta$[]) -> Ta$[]
takeWhile = takewhile

dropWhile: (Ta -> bool, Ta$[]) -> Ta$[]
dropWhile = dropwhile

if TYPE_CHECKING:
    def span(cond: Ta -> bool, xs: Ta[]) -> T.Tuple[Ta[], Ta[]] =
        ...  # type: ignore
else:
    match def span(_, []) = ([], [])
    addpattern def span(cond, [x] + xs if cond(x)) =
        ys, zs = span(cond, xs)
        ([x] + ys, zs)
    addpattern def span(cond, xs) =
        ([], xs)

def break_(cond: Ta -> bool, xs: Ta[]) -> Ta[] =
    """
    break_ = break
    """
    span((not)..cond, xs)



## Searching lists:
def notElem(e: Ta, xs: Ta[]) -> bool =
    e not in xs

def lookup(key: Ta, assocs: T.Tuple[Ta, Tb]$[]) -> Maybe:
    try:
        return (
            assocs
            |> dropwhile$(pair -> pair[0] != key)
            |> .$[0]
            |> .[1]
            |> Just
        )
    except StopIteration:
        return nothing



## Zipping and unzipping lists:
zip: (Ta$[], Tb$[]) -> T.Tuple[Ta, Tb]$[]
zip = _zip

zip3: (Ta$[], Tb$[], Tc$[]) -> T.Tuple[Ta, Tb, Tc]$[]
zip3 = _zip

def zipWith(func: (Ta, Tb) -> Tc, xs1: Ta$[], xs2: Tb$[]) -> Tc$[] =
    starmap(func, zip(xs1, xs2))

def zipWith3(func: (Ta, Tb, Tc) -> Td, xs1: Ta$[], xs2: Tb$[], xs3: Tc$[]) -> Td$[] =
    starmap(func, _zip(xs1, xs2, xs3))

def unzip(xs: T.Tuple[Ta, Tb]$[]) -> T.Tuple[Ta[], Tb[]] =
    _zip(*xs) |> map$(list) |> tuple

unzip3: T.Tuple[Ta, Tb, Tc]$[] -> T.Tuple[Ta[], Tb[], Tc[]]
unzip3 = unzip  # type: ignore



## Functions on strings:
lines: str -> str[]
lines = .splitlines()

words: str -> str[]
words = .split()

def unlines(strs: str$[]) -> str =
    "".join(s + "\n" for s in strs)

unwords: str$[] -> str
unwords = " ".join




# Converting to and from String:

## Converting to String:
ShowS = T.Callable[[str], str]

Show = T.Any

showsPrec = NotImplemented

show: Ta -> str
show = repr

def shows(x: Show) -> ShowS =
    s -> repr(x) + s

def showList(xs: Show$[]) -> ShowS =
    s -> repr(list(xs)) + s

def showString(x: str) -> ShowS =
    s -> x + s

showChar: Char -> ShowS
showChar = showString

def showParen(parens: bool, showFunc: ShowS) -> ShowS =
    s -> (
        "(" + showFunc("") + ")" + s if parens
        else showFunc("") + s
    )



## Converting from String:
ReadS = NotImplemented

Read = T.Union[
    str,
    int,
    float,
    bool,
    None,
    tuple,
    list,
    dict,
]

readsPrec = NotImplemented

readList = NotImplemented

reads = NotImplemented

readParen = NotImplemented

def read(s: str) -> Read =
    _ast.literal_eval(s)

lex = NotImplemented




# Basic input and output:

#### IO:
data IO(io_func):
    @staticmethod
    def __pure__(x: Ta) -> IO =
        IO(() -> x)

    @staticmethod
    def __fail__(msg: str) -> IO =
        IO(def () -> raise IOError(msg))

    def __fmap__(self, func: Ta -> Tb) -> IO =
        IO(func..self.io_func)

    def __join__(self) -> IO =
        fmap(unIO, self)

    @staticmethod
    def __mempty__() -> IO =
        IO(() -> mempty)

    def __mappend__(self, other: IO) -> IO =
        IO(() -> mappend(self.io_func(), other.io_func()))

_nullIO: IO = IO(() -> None)

def asIO(io: IO) -> IO =
    """
    asIO :: IO a -> IO a
    asIO = id
    -- asIO(x) is equivalent to x `asTypeOf` IO(...)
    """
    io `asTypeOf` _nullIO

def unIO(io: IO) -> Ta =
    """
    The unIO function is an impure function which performs the
    I/O contained in the given IO object and returns the result.
    In particular, the recommendation is to write
        @unIO
        @do$([io1, io2, ...])
        def main(r1, r2, ...) =
            ...
    which is equivalent to the Haskell code
        main = do
            r1 <- io1
            r2 <- io2
            ...
    """
    asIO(io).io_func()




## Simple I/O operations:

### Output functions:
def putStr(s: str) -> IO =
    IO(_print$(s, end=""))

putChar: Char -> IO
putChar = putStr

def putStrLn(s: str) -> IO =
    IO(_print$(s))

def print(x: Ta) -> IO =
    IO(_print$(show(x)))


### Input functions:
getChar: IO = IO(sys.stdin.read$(1))

getLine: IO = IO(input)

getContents: IO = IO(sys.stdin.read)

def interact(func: str -> str) -> IO =
    def do_interact():
        while True:
            input() |> func |> _print
    IO(do_interact)


### Files:
FilePath = str

def readFile(fpath: FilePath) -> IO =
    def do_readFile() -> str:
        with open(fpath, "r+") as f:
            return f.read()
    IO(do_readFile)

def writeFile(fpath: FilePath, text: str) -> IO =
    def do_writeFile() -> None:
        with open(fpath, "w+") as f:
            f.write(text)
    IO(do_writeFile)

def appendFile(fpath: FilePath, text: str) -> IO =
    def do_appendFile() -> None:
        with open(fpath, "a+") as f:
            f.write(text)
    IO(do_appendFile)

def readIO(s: str) -> IO =
    IO(read$(s))

def readLn() -> IO =
    getLine() `bind` readIO  # type: ignore



## Exception handling:
def ioError(err: IOError) -> IO =
    IO(def () -> raise err)

def userError(msg: str) -> IOError =
    IOError(msg)
