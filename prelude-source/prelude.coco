# Helpers:

#### Imports:
import sys
import typing as _t
import fractions as _fractions
import math as _math

#### Untyped built-ins:
_max: -> _t.Any = max
_min: -> _t.Any = min
_zip: -> _t.Any = zip
_abs: -> _t.Any = abs
_round: -> _t.Any = round
_fmap: -> _t.Any = fmap
_reduce: -> _t.Any = reduce
_all: -> _t.Any = all
_any: -> _t.Any = any
_map: -> _t.Any = map
_filter: -> _t.Any = filter
_int: -> _t.Any = int
_sum: -> _t.Any = sum
_reversed: -> _t.Any = reversed
_ceil: -> _t.Any = _math.ceil
_floor: -> _t.Any = _math.floor
_IOError: _t.Any = IOError

#### TypeVars:
_a = _t.TypeVar("_a")
_b = _t.TypeVar("_b")
_c = _t.TypeVar("_c")
_d = _t.TypeVar("_d")

#### Deriving:
def derivingEqOrd(*valueConstructors: object) -> None:
    """
    The expression
        derivingEqOrd(valueConstructor1, valueConstructor2, ...)
    is equivalent to stating that for some data type defined as
        data dataType = valueConstructor1 ... | valueConstructor2 ... | ...
    we should add
        deriving (Eq, Ord)
    """
    if TYPE_CHECKING: return
    ind = valueConstructors.index..type
    for valCon in valueConstructors:
        def valCon.__eq__(x, y) =
            type(x) is type(y) and tuple.__eq__(x, y)
        def valCon.__lt__(x, y) =
            tuple.__lt__(x, y) if type(x) is type(y) else ind(x) < ind(y)
        def valCon.__le__(x, y) =
            tuple.__le__(x, y) if type(x) is type(y) else ind(x) <= ind(y)
        def valCon.__ge__(x, y) =
            tuple.__ge__(x, y) if type(x) is type(y) else ind(x) >= ind(y)
        def valCon.__gt__(x, y) =
            tuple.__gt__(x, y) if type(x) is type(y) else ind(x) > ind(y)

def derivingEnum(*valueConstructors: object) -> None:
    """
    The expression
        derivingEnum(valueConstructor1, valueConstructor2, ...)
    is equivalent to stating that for some data type defined as
        data dataType = valueConstructor1 ... | valueConstructor2 ... | ...
    we should add
        deriving (Enum)
    """
    if TYPE_CHECKING: return
    ind = valueConstructors.index..type
    for valCon in valueConstructors:
        def valCon.__int__(x) = ind(x)
        def valCon.__add__(x, y) =
            valueConstructors[ind(x) + y]() if isinstance(y, int) else tuple.__add__(x, y)
        def valCon.__radd__(x, y) = x + y
        def valCon.__sub__(x, y) =
            valueConstructors[ind(x) - y]() if isinstance(y, int) else tuple.__sub__(x, y)




# Standard types, classes, and related functions:

## Basic data types:

#### Bool:
Bool = bool

not_: bool -> bool
not_ = (not)

otherwise: bool = True

#### Maybe:
class Maybe

data Nothing() from Maybe
nothing: Maybe = Nothing()

data Just(x) from Maybe

derivingEqOrd(Nothing, Just)

if TYPE_CHECKING:
    def maybe(default: _b, func: _a -> _b, x: Maybe) -> _b =
        ...  # type: ignore
else:
    def maybe(default, _, Nothing()) = default

    @addpattern(maybe)
    def maybe(_, func, Just(x)) = func(x)

#### Either:
class Either

data Left(x) from Either:
    def __fmap__(self, func) = self
    def __bool__(self) = False

data Right(x) from Either

derivingEqOrd(Left, Right)

if TYPE_CHECKING:
    def either(left_func: _a -> _c, right_func: _b -> _c, x: Either) -> _c =
        ...  # type: ignore
else:
    def either(left_func, _, Left(x)) = left_func(x)

    @addpattern(either)
    def either(_, right_func, Right(x)) = right_func(x)

#### Ordering:
class Ordering

data LT() from Ordering
lt: Ordering = LT()

data EQ() from Ordering
eq: Ordering = EQ()

data GT() from Ordering
gt: Ordering = GT()

derivingEqOrd(LT, EQ, GT)
derivingEnum(LT, EQ, GT)

#### Char:
Char = str

#### String:
String = str


### Tuples:
fst: _t.Tuple[_a, _b] -> _a
fst = .[0]

snd: _t.Tuple[_a, _b] -> _b
snd = .[1]

def curry(func: (_a, _b) -> _c) -> _a -> _b -> _c =
    func$  # type: ignore

def uncurry(func: _a -> _b -> _c) -> (_a, _b) -> _c =
    (x, y) -> func(x)(y)



## Basic type classes:

#### Eq:
Eq = object

#### Ord:
Ord = Eq
_O = _t.TypeVar("_O", bound=Ord)

if TYPE_CHECKING:
    def compare(x: Ord, y: Ord) -> Ordering =
        ...  # type: ignore
else:
    def compare(x, y if x == y) = eq

    @addpattern(compare)
    def compare(x, y if x < y) = lt

    @addpattern(compare)
    def compare(x, y if x > y) = gt

max: (_O, _O) -> _O
max = _max

min: (_O, _O) -> _O
min = _min

#### Enum:
Enum = Ord
_E = _t.TypeVar("_E", bound=Enum)

succ: _E -> _E
succ = (+)$(1)

pred: _E -> _E
pred = (-)$(?, 1)

toEnum = NotImplemented

fromEnum: Enum -> int
fromEnum = _int

def enumFrom(first: _E) -> _E$[] =
    iterate(succ, first)

def enumFromThen(first: _E, second: _E) -> _E$[] =
    step = fromEnum(second) - fromEnum(first)
    iterate((+)$(step), first) if step >= 0 else ()  # type: ignore

def enumFromTo(first: _E, last: _E) -> _E$[] =
    dist = fromEnum(last) - fromEnum(first)
    iterate(succ, first)$[:dist+1] if dist >= 0 else ()

def enumFromThenTo(first: _E, second: _E, last: _E) -> _E$[] =
    step = fromEnum(second) - fromEnum(first)
    dist = fromEnum(last) - fromEnum(first)
    steps = dist/step if step != 0 else 0
    if steps < 0:
        return ()
    counter = iterate((+)$(step), first)
    counter$[:int(steps)+1] if steps != 0 else counter


#### Bounded:
Bounded = _t.Union[bool, Ordering]
_B = _t.TypeVar("_B", bound=Bounded)

if TYPE_CHECKING:
    def minBound(b: _B) -> _B =
        ...  # type: ignore
else:
    def minBound(b is bool) = False

    @addpattern(minBound)
    def minBound(b is Ordering) = lt

if TYPE_CHECKING:
    def maxBound(b: _B) -> _B =
        ...  # type: ignore
else:
    def maxBound(b is bool) = True

    @addpattern(maxBound)
    def maxBound(b is Ordering) = gt



## Numbers:

### Numeric types:

#### Int:
Int = int

#### Integer:
Integer = int

#### Float:
Float = float

#### Double:
Double = float

#### Rational:
Rational = _fractions.Fraction

def over(x, y) =
    """
    import Data.Ratio
    over :: Integer -> Integer -> Rational
    over = (%)
    """
    Rational(x, y)

#### Word:
Word = Int


### Numeric type classes:

#### Num:
Num = _t.Union[int, float, Rational]
_N = _t.TypeVar("_N", bound=Num)

negate: _N -> _N
negate = (-)

abs: _N -> _N
abs = _abs

if TYPE_CHECKING:
    def signum(x: Num) -> int =
        ...  # type: ignore
else:
    def signum(0) = 0

    @addpattern(signum)
    def signum(x if x > 0) = 1

    @addpattern(signum)
    def signum(x if x < 0) = -1

def fromInteger(x: Integer) -> Num = x

#### Real:
Real = Num

if TYPE_CHECKING:
    def toRational(real: Real) -> Rational =
        ...  # type: ignore

else:
    def toRational(real is float) =
        Rational.from_float(real)

    @addpattern(toRational)
    def toRational(real) =
        Rational(real)

#### Integral:
Integral = int

def quot(x: int, y: int) -> int =
    divxy = x // y
    divxy + (1 if divxy < 0 and x % y != 0 else 0)

def rem(x: int, y: int) -> int =
    modxy = x % y
    modxy - (y if modxy != 0 and x // y < 0 else 0)

div: (int, int) -> int
div = (//)

mod: (int, int) -> int
mod = (%)

def quotRem(x: int, y: int) -> _t.Tuple[int, int] =
    divxy, modxy = divmod(x, y)
    adj = 1 if divxy < 0 and modxy != 0 else 0
    divxy + adj, modxy - y*adj

divMod = divmod

toInteger: Integral -> Integer
toInteger = _int

#### Fractional:
Fractional = Rational

recip: Fractional -> Fractional
recip = (/)$(1)

def fromRational(x: Rational) -> Fractional = x

#### Floating:
Floating = float

from math import (
    pi,
    exp,
    log,
    sqrt,
    sin,
    cos,
    tan,
    asin,
    acos,
    atan,
    sinh,
    cosh,
    tanh,
    asinh,
    acosh,
    atanh,
)

def logBase(base: float, x: float) -> float =
    log(x, base)

#### RealFrac:
RealFrac = Rational

def properFraction(x: RealFrac) -> _t.Tuple[int, RealFrac] =
    floor_x = floor(x)
    floor_x, x - floor_x

truncate: RealFrac -> int
truncate = _int

round: RealFrac -> int
round = _round

ceiling: RealFrac -> int
ceiling = _ceil

floor: RealFrac -> int
floor = _floor

#### RealFloat:
RealFloat = float

def floatRadix(x: float) -> int = 2

def floatDigits(x: float) -> int = 53

def floatRange(x: float) -> _t.Tuple[int, int] = (-1021, 1024)

decodeFloat = NotImplemented

encodeFloat = NotImplemented

exponent = NotImplemented

significand = NotImplemented

def scaleFloat(power: int, x: float) -> float =
    x * 2**power

from math import (
    isnan as isNaN,
    isinf as isInfinite,
    atan2,
)

isDenormalized = NotImplemented

def isNegativeZero(x: float) -> bool =
    x == 0 and str(x).startswith("-")

def isIEEE(x: float) -> bool = True


### Numeric functions:
def subtract(x, y) =
    y - x

def even(x: int) -> bool =
    x % 2 == 0

def odd(x: int) -> bool =
    x % 2 == 1

gcd: (int, int) -> int
gcd = abs.._fractions.gcd

if TYPE_CHECKING:
    def lcm(x: int, y: int) -> int =
        ...  # type: ignore
else:
    def lcm(_, 0) = 0

    @addpattern(lcm)
    def lcm(0, _) = 0

    @addpattern(lcm)
    def lcm(x, y) =
        abs(y) * (abs(x) // gcd(x, y))

fromIntegral: Integral -> Num
fromIntegral = fromInteger

realToFrac: Real -> Fractional
realToFrac = toRational



## Monoids:
Monoid = NotImplemented

mempty = NotImplemented

mappend = NotImplemented

mconcat = NotImplemented



## Monads and functors:

#### Functor:
Functor = _t.Iterable

fmap: (_a -> _b, Functor[_a]) -> Functor[_b]
fmap = _fmap

def fmapConst(x: _a, xs: Functor) -> Functor[_a] =
    """
    fmapConst :: Functor f => (a -> b) -> f a -> f b
    fmapConst = (<$)
    """
    _fmap(_ -> x, xs)

#### Applicative:
Applicative = Functor
_A = _t.TypeVar("_A", bound=Applicative)

data pure(val)

def ap(fs: Applicative[_a -> _b], xs: Applicative[_a]) -> Applicative[_b] =
    """
    ap :: Applicative f => f (a -> b) -> f a -> f b
    ap = (<*>)
    """
    fs `bind` f -> _fmap(f, xs)

def seqAr(f1: Applicative, f2: _A) -> _A =
    """
    seqAr :: Applicative f => f a -> f b -> f b
    seqAr = (*>)
    """
    _fmap(x1 -> x2 -> x2, f1) `ap` f2

def seqAl(f1: _A, f2: Applicative) -> _A =
    """
    seqAl :: Applicative f => f a -> f b -> f a
    seqAl = (<*)
    """
    _fmap(x1 -> x2 -> x1, f1) `ap` f2

def liftA2(func: (_a, _b) -> _c, f1: Applicative[_a], f2: Applicative[_b]) -> Applicative[_c] =
    """
    import Control.Applicative
    liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
    """
    _fmap(func$, f1) `ap` f2

#### Monad:
Monad = Applicative
_M = _t.TypeVar("_M", bound=Monad)

def bind(m: Monad[_a], func: _a -> _M) -> _M =
    """
    bind :: Monad m => m a -> (a -> m b) -> m b
    bind = (>>=)
    """
    join(_fmap(func, m))

def seqM(m1: Monad, m2: _M) -> _M =
    """
    seqM :: Monad m => m a -> m b -> m b
    seqM = (>>)
    """
    m1 `bind` x -> m2

return_ = pure

fail = Left

# sequence_ and mapM_ defined in Foldable

def bindFrom(func: _a -> Monad, m: Monad[_a]) =
    """
    bindFrom :: Monad m => (a -> m b) -> m a -> m b
    bindFrom = (=<<)
    """
    m `bind` func

if TYPE_CHECKING:
    def join(ms: Monad[_M]) -> _M =
        ...  # type: ignore
else:
    def join(ms if not ms) = ms

    @addpattern(join)
    def join(ms) =
        """
        import Control.Monad
        join :: Monad m => m (m a) -> m a
        """
        valCons = type(ms)
        vals = None
        for m in ms:
            if not m `isinstance` pure:
                valCons = type(m)
            vals = (::)(vals, m) if vals is not None else m
        makedata(valCons, *vals) if vals is not None else ms

if TYPE_CHECKING:
    def do(monads: _M[], func: -> _M) -> _M =
        ...  # type: ignore
else:
    def do([], func) = func()

    @addpattern(do)
    def do([m] + ms, func) =
        """
        The call
            do([m1, m2, ...], func)
        is equivalent to the sequence of binds
            m1 `bind` x1 ->
                m2 `bind` x2 ->
                    ...
                        func(x1, x2, ...)
        which is meant to mimic the do notation
            x1 <- m1
            x2 <- m2
            ...
            func(x1, x2, ...)
        """
        m `bind` x -> do(ms, func$(x))



## Folds and traversals:

#### Foldable:
Foldable = _t.Sequence

def sequence_(ms: Foldable[Monad]) -> Monad =
    do(ms, (*xs) -> pure(()))

mapM_: (_a -> Monad, Foldable[_a]) -> Monad
mapM_ = sequence_..fmap

fold = NotImplemented

foldMap = NotImplemented

def foldl(func: (_b, _a) -> _b, init: _b, xs: Foldable[_a]) -> _b =
    _reduce(func, xs, init)

def foldr(func: (_a, _b) -> _b, init: _b, xs: Foldable[_a]) -> _b =
    _reduce((x, y) -> func(y, x), reversed(xs), init)

foldl1: ((_a, _a) -> _a, Foldable[_a]) -> _a
foldl1 = reduce

def foldr1(func: (_a, _a) -> _a, xs: Foldable[_a]) -> _a =
    reduce((x, y) -> func(y, x), reversed(xs))

def null(xs: Foldable[_a]) -> bool = len(xs) == 0

length: Foldable -> int
length = len

def elem(e: _a, xs: Foldable[_a]) -> bool = e in xs

maximum: Foldable[_O] -> _O
maximum = _max

minimum: Foldable[_O] -> _O
minimum = _min

sum: Foldable[_N] -> _N
sum = _sum

product: Foldable[_N] -> _N
product = reduce$(*)

#### Traversable:
Traversable = _t.Iterable

def sequenceA(fs: Traversable[Applicative[_a]]) -> Applicative[Traversable[_a]] =
    fs `do` (*xs) -> xs |> makedata$(type(fs)) |> pure

traverse: (_a -> Applicative[_b], Traversable[_a]) -> Applicative[Traversable[_b]]
traverse = sequenceA..fmap

sequence: Traversable[Monad[_a]] -> Monad[Traversable[_a]]
sequence = sequenceA

mapM: (_a -> Monad[_b], Traversable[_a]) -> Monad[Traversable[_b]]
mapM = sequence..fmap



## Miscellaneous functions:
def id(x: _a) -> _a = x

def const(x: _a, _) -> _a = x

def dot(f: _b -> _c, g: _a -> _b) -> _a -> _c =
    """
    dot :: (b -> c) -> (a -> b) -> a -> c
    dot = (.)
    """
    f..g

def flip(func: (_a, _b) -> _c) -> (_b, _a) -> _c =
    (x, y) -> func(y, x)

def apply(func: _a -> _b, arg: _a) -> _b =
    """
    apply :: (a -> b) -> a -> b
    apply = ($)
    """
    func(arg)

def until(cond: _a -> bool, func: _a -> _a, x: _a) -> _a =
    if cond(x):
        return x
    until(cond, func, func(x))  # tail recursive

asTypeOf: (_a, _a) -> _a
asTypeOf = const

def error(msg: str) -> None: raise Exception(msg)

errorWithoutStackTrace = NotImplemented

undefined: _t.Any = None

def seq(x, y: _b) -> _b = y

def cbv(func: _a -> _b, arg: _a) -> _b =
    """
    cbv :: (a -> b) -> a -> b
    cbv = ($!)
    """
    func(arg)




# List operations:
def cons(x: _a, xs: _a$[]) -> _a$[] =
    """
    cons :: a -> [a] -> [a]
    cons = (:)
    """
    (::)([x], xs)

map: (_a -> _b, _a$[]) -> _b$[]
map = _map

def append(xs: _a$[], ys: _a$[]) -> _a$[] =
    """
    append :: [a] -> [a] -> [a]
    append = (++)
    """
    (::)(xs, ys)

filter: (_a -> bool, _a$[]) -> _a$[]
filter = _filter

head: _a$[] -> _a
head = .$[0]

last: _a$[] -> _a
last = .$[-1]

tail: _a$[] -> _a$[]
tail = .$[1:]  # type: ignore

init: _a$[] -> _a$[]
init = .$[:-1]  # type: ignore

def index(xs: _a$[], i: int) -> _a =
    xs$[i]

reverse: _a[] -> _a[]
reverse = _reversed



## Special folds:
and_: Foldable[bool] -> bool
and_ = _all

or_: Foldable[bool] -> bool
or_ = _any

any: ((_a -> bool), Foldable[_a]) -> bool
any = or_..map

all: ((_a -> bool), Foldable[_a]) -> bool
all = and_..map

concat: Foldable[_a$[]] -> _a$[]
concat = _reduce$(::)

concatMap: (_a -> _b$[], Foldable[_a]) -> _b$[]
concatMap = concat..map  # type: ignore



## Building lists:

### Scans:
def scanl(func: (_a, _b) -> _a, init: _a, xs: _b[]) -> _a$[] =
    scan(func, reversed(xs), init)

def scanl1(func: (_a, _a) -> _a, xs: _a[]) -> _a$[] =
    scan(func, reversed(xs))

def scanr(func: (_a, _b) -> _a, init: _a, xs: _b$[]) -> _a$[] =
    scan(func, xs, init)

scanr1: ((_a, _a) -> _a, _a$[]) -> _a$[]
scanr1 = scan

### Infinite lists:
@recursive_iterator
def iterate(func: _a -> _a, x: _a) -> _a$[] =
    [x] :: iterate(func, func(x))

@recursive_iterator
def repeat(x: _a) -> _a$[] =
    [x] :: repeat(x)

def replicate(n: int, x: _a) -> _a$[] =
    repeat(x)$[:n]

if TYPE_CHECKING:
    def cycle(xs: _a$[]) -> _a$[] =
        ...  # type: ignore
else:
    @recursive_iterator
    def cycle(xs if len(xs) > 0) =
        xs :: cycle(xs)



## Sublists:
def take(n: int, xs: _a$[]) -> _a$[] =
    xs$[:n]

def drop(n: int, xs: _a$[]) -> _a$[] =
    xs$[n:]

def splitAt(n: int, xs: _a$[]) -> _t.Tuple[_a$[], _a$[]] =
    reit = reiterable(xs)
    reit$[:n], reit$[n:]

takeWhile: (_a -> bool, _a$[]) -> _a$[]
takeWhile = takewhile

dropWhile: (_a -> bool, _a$[]) -> _a$[]
dropWhile = dropwhile

if TYPE_CHECKING:
    def span(cond: _a -> bool, xs: _a[]) -> _a[] =
        ...  # type: ignore
else:
    def span(_, []) = ([], [])

    @addpattern(span)
    def span(cond, [x] + xs if cond(x)) =
        ys, zs = span(cond, xs)
        ([x] + ys, zs)

    @addpattern(span)
    def span(cond, xs) =
        ([], xs)

def break_(cond: _a -> bool, xs: _a[]) -> _a[] =
    span((not)..cond, xs)



## Searching lists:
def notElem(e: _a, xs: _a[]) -> bool =
    e not in xs

def lookup(key: _a, assocs: _t.Tuple[_a, _b]$[]) -> Maybe:
    try:
        return (
            assocs
            |> dropwhile$(pair -> pair[0] != key)
            |> .$[0]
            |> .[1]
            |> Just
        )
    except StopIteration:
        return nothing



## Zipping and unzipping lists:
zip: (_a$[], _b$[]) -> _t.Tuple[_a, _b]$[]
zip = _zip

zip3: (_a$[], _b$[], _c$[]) -> _t.Tuple[_a, _b, _c]$[]
zip3 = _zip

def zipWith(func: (_a, _b) -> _c, xs1: _a$[], xs2: _b$[]) -> _c$[] =
    starmap(func, zip(xs1, xs2))

def zipWith3(func: (_a, _b, _c) -> _d, xs1: _a$[], xs2: _b$[], xs3: _c$[]) -> _d$[] =
    starmap(func, _zip(xs1, xs2, xs3))

def unzip(xs: _t.Tuple[_a, _b]$[]) -> _t.Tuple[_a[], _b[]] =
    _zip(*xs) |> tuple  # type: ignore

def unzip3(xs: _t.Tuple[_a, _b, _c]$[]) -> _t.Tuple[_a[], _b[], _c[]] =
    _zip(*xs) |> tuple  # type: ignore



## Functions on strings:
lines: str -> str[]
lines = .split("\n")  # type: ignore

words: str -> str[]
words = .split()  # type: ignore

unlines: str[] -> str
unlines = "\n".join

unwords: str[] -> str
unwords = " ".join




# Converting to and from String:

## Converting to String:
show: _a -> str
show = str




# Basic input and output:

## Simple I/O operations:

### Output functions:
putStr: str -> None
putStr = print$(end="")

putChar: Char -> None
putChar = putStr

putStrLn: str -> None
putStrLn = print


### Input functions:
getChar: () -> str
getChar = sys.stdin.read$(1)

getLine: () -> str
getLine = input

getContents: () -> str
getContents = sys.stdin.read

def interact(func: str -> str) -> None:
    while True:
        input() |> func |> print


### Files:
FilePath = _t.NewType("FilePath", str)

def readFile(fpath: FilePath) -> str:
    with open(fpath, "r+") as f:
        return f.read()

def writeFile(fpath: FilePath, text: str) -> None:
    with open(fpath, "w+") as f:
        f.write(text)  # type: ignore

def appendFile(fpath: FilePath, text: str) -> None:
    with open(fpath, "a+") as f:
        f.write(text)  # type: ignore



## Exception handling:
IOError: _t.Type[Exception]
IOError = _IOError

def ioError() -> None: raise IOError()

def userError(msg: str) -> None: raise IOError(msg)
