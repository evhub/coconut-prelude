# Helpers:

#### Imports:
import sys
import fractions as _fractions
import math as _math

from .util import *  # type: ignore

#### Untyped built-ins:
_max: -> T.Any = max
_min: -> T.Any = min
_zip: -> T.Any = zip
_abs: -> T.Any = abs
_round: -> T.Any = round
_fmap: -> T.Any = fmap
_reduce: -> T.Any = reduce
_all: -> T.Any = all
_any: -> T.Any = any
_map: -> T.Any = map
_filter: -> T.Any = filter
_int: -> T.Any = int
_sum: -> T.Any = sum
_reversed: -> T.Any = reversed
_ceil: -> T.Any = _math.ceil
_floor: -> T.Any = _math.floor
_IOError: T.Any = IOError




# Standard types, classes, and related functions:

## Basic data types:

#### Bool:
Bool = bool

not_: bool -> bool
not_ = (not)

otherwise: bool = True

#### Maybe:
class Maybe:
    @staticmethod
    def __pure__(obj: Ta) -> Maybe = Just(obj)

    @staticmethod
    def __fail__(msg: str) -> Maybe = nothing

    @staticmethod
    def __mempty__() -> Maybe = nothing

data Nothing() from Maybe
nothing: Maybe = Nothing()

data Just(x) from Maybe

derivingEqOrd(Nothing, Just)

if TYPE_CHECKING:
    def maybe(default: Tb, func: Ta -> Tb, x: Maybe) -> Tb =
        ...  # type: ignore
else:
    def maybe(default, _, Nothing()) = default

    @addpattern(maybe)
    def maybe(_, func, Just(x)) = func(x)

#### Either:
class Either:
    @staticmethod
    def __pure__(obj: Ta) -> Either = Right(obj)

    @staticmethod
    def __fail__(msg: str) -> Either = Left(msg)

data Left(x) from Either:
    @staticmethod
    def __bool__() -> bool = False

    def __fmap__(self, func: Ta -> Tb) -> Either = self

data Right(x) from Either

derivingEqOrd(Left, Right)

if TYPE_CHECKING:
    def either(left_func: Ta -> Tc, right_func: Tb -> Tc, x: Either) -> Tc =
        ...  # type: ignore
else:
    def either(left_func, _, Left(x)) = left_func(x)

    @addpattern(either)
    def either(_, right_func, Right(x)) = right_func(x)

#### Ordering:
class Ordering:
    @staticmethod
    def __mempty__() -> Ordering = eq

data LT() from Ordering:
    @staticmethod
    def __bool__() -> bool = True

data EQ() from Ordering

data GT() from Ordering:
    @staticmethod
    def __bool__() -> bool = True

lt: Ordering = LT()
eq: Ordering = EQ()
gt: Ordering = GT()

derivingEqOrd(LT, EQ, GT)
derivingEnum(LT, EQ, GT)

#### Char:
Char = str

#### String:
String = str


### Tuples:
fst: T.Tuple[Ta, Tb] -> Ta
fst = .[0]

snd: T.Tuple[Ta, Tb] -> Tb
snd = .[1]

def curry(func: (Ta, Tb) -> Tc) -> Ta -> Tb -> Tc =
    func$  # type: ignore

def uncurry(func: Ta -> Tb -> Tc) -> (Ta, Tb) -> Tc =
    (x, y) -> func(x)(y)



## Basic type classes:

#### Eq:
Eq = object

#### Ord:
Ord = Eq
TOrd = T.TypeVar("TOrd", bound=Ord)

if TYPE_CHECKING:
    def compare(x: Ord, y: Ord) -> Ordering =
        ...  # type: ignore
else:
    def compare(x, y if x == y) = eq

    @addpattern(compare)
    def compare(x, y if x < y) = lt

    @addpattern(compare)
    def compare(x, y if x > y) = gt

max: (TOrd, TOrd) -> TOrd
max = _max

min: (TOrd, TOrd) -> TOrd
min = _min

#### Enum:
Enum = Ord
TEnum = T.TypeVar("TEnum", bound=Enum)

succ: TEnum -> TEnum
succ = (+)$(1)

pred: TEnum -> TEnum
pred = (-)$(?, 1)

toEnum = NotImplemented

fromEnum: Enum -> int
fromEnum = _int

def enumFrom(first: TEnum) -> TEnum$[] =
    iterate(succ, first)

def enumFromThen(first: TEnum, second: TEnum) -> TEnum$[] =
    step = fromEnum(second) - fromEnum(first)
    iterate((+)$(step), first) if step >= 0 else ()  # type: ignore

def enumFromTo(first: TEnum, last: TEnum) -> TEnum$[] =
    dist = fromEnum(last) - fromEnum(first)
    iterate(succ, first)$[:dist+1] if dist >= 0 else ()

def enumFromThenTo(first: TEnum, second: TEnum, last: TEnum) -> TEnum$[] =
    step = fromEnum(second) - fromEnum(first)
    dist = fromEnum(last) - fromEnum(first)
    steps = dist/step if step != 0 else 0
    if steps < 0:
        return ()
    counter = iterate((+)$(step), first)
    counter$[:int(steps)+1] if steps != 0 else counter


#### Bounded:
Bounded = T.Union[bool, Ordering]
TBounded = T.TypeVar("TBounded", bound=Bounded)

if TYPE_CHECKING:
    def minBound(b: TBounded) -> TBounded =
        ...  # type: ignore
else:
    def minBound(b is bool) = False

    @addpattern(minBound)
    def minBound(b is Ordering) = lt

if TYPE_CHECKING:
    def maxBound(b: TBounded) -> TBounded =
        ...  # type: ignore
else:
    def maxBound(b is bool) = True

    @addpattern(maxBound)
    def maxBound(b is Ordering) = gt



## Numbers:

### Numeric types:

#### Int:
Int = int

#### Integer:
Integer = int

#### Float:
Float = float

#### Double:
Double = float

#### Rational:
Rational = _fractions.Fraction

def over(x, y) =
    """
    import Data.Ratio
    over :: Integer -> Integer -> Rational
    over = (%)
    """
    Rational(x, y)

#### Word:
Word = Int


### Numeric type classes:

#### Num:
Num = T.Union[int, float, Rational]
TNum = T.TypeVar("TNum", bound=Num)

negate: TNum -> TNum
negate = (-)

abs: TNum -> TNum
abs = _abs

if TYPE_CHECKING:
    def signum(x: Num) -> int =
        ...  # type: ignore
else:
    def signum(0) = 0

    @addpattern(signum)
    def signum(x if x > 0) = 1

    @addpattern(signum)
    def signum(x if x < 0) = -1

def fromInteger(x: Integer) -> Num = x

#### Real:
Real = Num

if TYPE_CHECKING:
    def toRational(real: Real) -> Rational =
        ...  # type: ignore

else:
    def toRational(real is float) =
        Rational.from_float(real)

    @addpattern(toRational)
    def toRational(real) =
        Rational(real)

#### Integral:
Integral = int

def quot(x: int, y: int) -> int =
    divxy = x // y
    divxy + (1 if divxy < 0 and x % y != 0 else 0)

def rem(x: int, y: int) -> int =
    modxy = x % y
    modxy - (y if modxy != 0 and x // y < 0 else 0)

div: (int, int) -> int
div = (//)

mod: (int, int) -> int
mod = (%)

def quotRem(x: int, y: int) -> T.Tuple[int, int] =
    divxy, modxy = divmod(x, y)
    adj = 1 if divxy < 0 and modxy != 0 else 0
    divxy + adj, modxy - y*adj

divMod = divmod

toInteger: Integral -> Integer
toInteger = _int

#### Fractional:
Fractional = Rational

recip: Fractional -> Fractional
recip = (/)$(1)

def fromRational(x: Rational) -> Fractional = x

#### Floating:
Floating = float

from math import (
    pi,
    exp,
    log,
    sqrt,
    sin,
    cos,
    tan,
    asin,
    acos,
    atan,
    sinh,
    cosh,
    tanh,
    asinh,
    acosh,
    atanh,
)

def logBase(base: float, x: float) -> float =
    log(x, base)

#### RealFrac:
RealFrac = Rational

def properFraction(x: RealFrac) -> T.Tuple[int, RealFrac] =
    floor_x = floor(x)
    floor_x, x - floor_x

truncate: RealFrac -> int
truncate = _int

round: RealFrac -> int
round = _round

ceiling: RealFrac -> int
ceiling = _ceil

floor: RealFrac -> int
floor = _floor

#### RealFloat:
RealFloat = float

def floatRadix(x: float) -> int = 2

def floatDigits(x: float) -> int = 53

def floatRange(x: float) -> T.Tuple[int, int] = (-1021, 1024)

decodeFloat = NotImplemented

encodeFloat = NotImplemented

exponent = NotImplemented

significand = NotImplemented

def scaleFloat(power: int, x: float) -> float =
    x * 2**power

from math import (
    isnan as isNaN,
    isinf as isInfinite,
    atan2,
)

isDenormalized = NotImplemented

def isNegativeZero(x: float) -> bool =
    x == 0 and str(x).startswith("-")

def isIEEE(x: float) -> bool = True


### Numeric functions:
def subtract(x, y) =
    y - x

def even(x: int) -> bool =
    x % 2 == 0

def odd(x: int) -> bool =
    x % 2 == 1

gcd: (int, int) -> int
gcd = abs.._fractions.gcd

if TYPE_CHECKING:
    def lcm(x: int, y: int) -> int =
        ...  # type: ignore
else:
    def lcm(_, 0) = 0

    @addpattern(lcm)
    def lcm(0, _) = 0

    @addpattern(lcm)
    def lcm(x, y) =
        abs(y) * (abs(x) // gcd(x, y))

fromIntegral: Integral -> Num
fromIntegral = fromInteger

realToFrac: Real -> Fractional
realToFrac = toRational



## Monoids:
Monoid = T.Iterable
TMonoid = T.TypeVar("TMonoid", bound=Monoid)

data MEmpty():
    """
    -- mempty is overridden by the __mempty__ staticmethod
    """
    @staticmethod
    def __mempty__() -> MEmpty = mempty

    @staticmethod
    def mempty_as(M: T.Type[TMonoid]) -> TMonoid =
        if M `hasattr` "__mempty__":
            return M.__mempty__()  # type: ignore
        makedata(M)

mempty = MEmpty()

def mappend(x: TMonoid, y: TMonoid) -> TMonoid =
    """
    -- mappend is overridden by the __mappend__ method
    -- you may also want to define a __mempty__ staticmethod
    -- the default implementation identifies identities using __bool__
    """
    # Resolve memptys
    if x `isinstance` MEmpty:
        x = x.mempty_as(type(y))
    if y `isinstance` MEmpty:
        y = y.mempty_as(type(x))

    # Check if overridden
    if x `hasattr` "__mappend__":
        return x.__mappend__(y)  # type: ignore

    # Default implementation
    if not x:
        return y
    if not y:
        return x
    if x `isinstance` tuple and y `isinstance` tuple:
        return zipWith(mappend, x, y) |*> makedata$(type(x))
    (::)(x, y) |*> makedata$(type(x))

def mconcat(ms: TMonoid[]) -> TMonoid =
    foldr(mappend, mempty, ms)



## Monads and functors:

#### Functor:
Functor = T.Iterable

fmap: (Ta -> Tb, Functor[Ta]) -> Functor[Tb]
fmap = _fmap

def fmapConst(x: Ta, xs: Functor) -> Functor[Ta] =
    """
    fmapConst :: Functor f => (a -> b) -> f a -> f b
    fmapConst = (<$)
    """
    _fmap(_ -> x, xs)

#### Applicative:
Applicative = Functor
TApp = T.TypeVar("TApp", bound=Applicative)

data pure(val):
    """
    return_ = return
    -- pure/return is overridden by the __pure__ staticmethod
    """
    def __join__(self) -> T.Any = self.val

    def pure_as(self, M: T.Type[TApp]) -> TApp =
        if M `hasattr` "__pure__":
            return M.__pure__(self.val)  # type: ignore
        makedata(M, self.val)

def ap(fs: Applicative[Ta -> Tb], xs: Applicative[Ta]) -> Applicative[Tb] =
    """
    ap :: Applicative f => f (a -> b) -> f a -> f b
    ap = (<*>)
    -- ap is overridden by overriding join (__join__) and fmap (__fmap__)
    -- you may also want to define a __pure__ staticmethod
    """
    fs `bind` f -> _fmap(f, xs)

def seqAr(f1: Applicative, f2: TApp) -> TApp =
    """
    seqAr :: Applicative f => f a -> f b -> f b
    seqAr = (*>)
    """
    _fmap(x1 -> x2 -> x2, f1) `ap` f2

def seqAl(f1: TApp, f2: Applicative) -> TApp =
    """
    seqAl :: Applicative f => f a -> f b -> f a
    seqAl = (<*)
    """
    _fmap(x1 -> x2 -> x1, f1) `ap` f2

def liftA2(func: (Ta, Tb) -> Tc, f1: Applicative[Ta], f2: Applicative[Tb]) -> Applicative[Tc] =
    """
    import Control.Applicative
    liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
    """
    _fmap(func$, f1) `ap` f2

#### Monad:
Monad = Applicative
TMonad = T.TypeVar("TMonad", bound=Monad)

def bind(m: Monad[Ta], func: Ta -> TMonad) -> TMonad =
    """
    bind :: Monad m => m a -> (a -> m b) -> m b
    bind = (>>=)
    -- bind is overridden by overriding fmap (__fmap__) and join (__join__)
    """
    join(_fmap(func, m))

def seqM(m1: Monad, m2: TMonad) -> TMonad =
    """
    seqM :: Monad m => m a -> m b -> m b
    seqM = (>>)
    """
    m1 `bind` x -> m2

return_ = pure

data fail(msg):
    """
    -- fail is overridden by the __fail__ method
    """
    @staticmethod
    def __bool__() -> bool = False

    def __fmap__(self, func: Ta -> Tb) -> T.Any = self

    def fail_as(self, M: T.Type[TMonad]) -> TMonad =
        if M `hasattr` "__fail__":
            return M.__fail__(self.msg)  # type: ignore
        makedata(M)

# sequence_ and mapM_ defined in Foldable

def bindFrom(func: Ta -> TMonad, m: Monad[Ta]) -> TMonad =
    """
    bindFrom :: Monad m => (a -> m b) -> m a -> m b
    bindFrom = (=<<)
    """
    m `bind` func

def join(ms: Monad[TMonad]) -> TMonad =
    """
    import Control.Monad
    join :: Monad m => m (m a) -> m a
    -- join is overridden by the __join__ method
    -- you may also want to define __pure__ and __fail__ staticmethods (pure = return)
    -- the default implementation identifies failures using __bool__
    """
    # Resolve pures and fails
    valCons = type(ms)
    ms = ms |> fmap$(m ->
        m.fail_as(valCons) if m `isinstance` fail
        else m.pure_as(valCons) if m `isinstance` pure
        else m
    )  # type: ignore

    # Check if overridden
    if ms `hasattr` "__join__":
        return ms.__join__()  # type: ignore

    # Default implementation
    if not ms:
        return ms  # type: ignore
    vals = []  # type: ignore
    fallback = ms
    for m in ms:
        if m:
            vals.extend(m)
        else:
            fallback = m
    if not vals:
        return fallback  # type: ignore
    makedata(valCons, *vals)

if TYPE_CHECKING:
    def do(monads: TMonad[], func: -> TMonad) -> TMonad =
        ...  # type: ignore
else:
    def do([], func) = func()

    @addpattern(do)
    def do([m] + ms, func) =
        """
        The call
            do([m1, m2, ...], func)
        is equivalent to the sequence of binds
            m1 `bind` x1 ->
                m2 `bind` x2 ->
                    ...
                        func(x1, x2, ...)
        which is meant to mimic the do notation
            x1 <- m1
            x2 <- m2
            ...
            func(x1, x2, ...)
        """
        m `bind` x -> do(ms, func$(x))



## Folds and traversals:

#### Foldable:
Foldable = T.Sequence

def sequence_(ms: Foldable[Monad]) -> Monad =
    do(ms, (*xs) -> pure(()))

mapM_: (Ta -> Monad, Foldable[Ta]) -> Monad
mapM_ = sequence_..fmap

def foldMap(func: Ta -> TMonoid, xs: Foldable[Ta]) -> TMonoid =
    mconcat(map(func, xs))

def foldl(func: (Tb, Ta) -> Tb, init: Tb, xs: Foldable[Ta]) -> Tb =
    _reduce(func, xs, init)

def foldr(func: (Ta, Tb) -> Tb, init: Tb, xs: Foldable[Ta]) -> Tb =
    _reduce((x, y) -> func(y, x), reversed(xs), init)

foldl1: ((Ta, Ta) -> Ta, Foldable[Ta]) -> Ta
foldl1 = reduce

def foldr1(func: (Ta, Ta) -> Ta, xs: Foldable[Ta]) -> Ta =
    reduce((x, y) -> func(y, x), reversed(xs))

def null(xs: Foldable[Ta]) -> bool = len(xs) == 0

length: Foldable -> int
length = len

def elem(e: Ta, xs: Foldable[Ta]) -> bool = e in xs

maximum: Foldable[TOrd] -> TOrd
maximum = _max

minimum: Foldable[TOrd] -> TOrd
minimum = _min

sum: Foldable[TNum] -> TNum
sum = _sum

product: Foldable[TNum] -> TNum
product = reduce$(*)

#### Traversable:
Traversable = T.Iterable

def sequenceA(fs: Traversable[Applicative[Ta]]) -> Applicative[Traversable[Ta]] =
    fs `do` (*xs) -> xs |*> makedata$(type(fs)) |> pure

traverse: (Ta -> Applicative[Tb], Traversable[Ta]) -> Applicative[Traversable[Tb]]
traverse = sequenceA..fmap

sequence: Traversable[Monad[Ta]] -> Monad[Traversable[Ta]]
sequence = sequenceA

mapM: (Ta -> Monad[Tb], Traversable[Ta]) -> Monad[Traversable[Tb]]
mapM = traverse



## Miscellaneous functions:
def id(x: Ta) -> Ta = x

def const(x: Ta) -> Tb -> Ta =
    y -> x

def dot(f: Tb -> Tc, g: Ta -> Tb) -> Ta -> Tc =
    """
    dot :: (b -> c) -> (a -> b) -> a -> c
    dot = (.)
    """
    f..g

def flip(func: (Ta, Tb) -> Tc) -> (Tb, Ta) -> Tc =
    (x, y) -> func(y, x)

def apply(func: Ta -> Tb, arg: Ta) -> Tb =
    """
    apply :: (a -> b) -> a -> b
    apply = ($)
    """
    func(arg)

def until(cond: Ta -> bool, func: Ta -> Ta, x: Ta) -> Ta =
    if cond(x):
        return x
    until(cond, func, func(x))  # tail recursive

def asTypeOf(x: Ta, y: Ta) -> Ta = x

def error(msg: str) -> None: raise Exception(msg)

errorWithoutStackTrace = NotImplemented

undefined: T.Any = None

def seq(x: Ta, y: Tb) -> Tb = y

def cbv(func: Ta -> Tb, arg: Ta) -> Tb =
    """
    cbv :: (a -> b) -> a -> b
    cbv = ($!)
    """
    func(arg)




# List operations:
def cons(x: Ta, xs: Ta$[]) -> Ta$[] =
    """
    cons :: a -> [a] -> [a]
    cons = (:)
    """
    (::)([x], xs)

map: (Ta -> Tb, Ta$[]) -> Tb$[]
map = _map

def chain(xs: Ta$[], ys: Ta$[]) -> Ta$[] =
    """
    chain :: [a] -> [a] -> [a]
    chain = (++)
    """
    (::)(xs, ys)

filter: (Ta -> bool, Ta$[]) -> Ta$[]
filter = _filter

head: Ta$[] -> Ta
head = .$[0]

last: Ta$[] -> Ta
last = .$[-1]

tail: Ta$[] -> Ta$[]
tail = .$[1:]  # type: ignore

init: Ta$[] -> Ta$[]
init = .$[:-1]  # type: ignore

def at(xs: Ta$[], i: int) -> Ta =
    """
    at :: [a] -> Int -> a
    at = (!!)
    """
    xs$[i]

reverse: Ta[] -> Ta[]
reverse = _reversed



## Special folds:
and_: Foldable[bool] -> bool
and_ = _all

or_: Foldable[bool] -> bool
or_ = _any

any: ((Ta -> bool), Foldable[Ta]) -> bool
any = or_..map

all: ((Ta -> bool), Foldable[Ta]) -> bool
all = and_..map

def concat(xs: Foldable[Ta$[]]) -> Ta$[] =
    _reduce((::), xs, ())

concatMap: (Ta -> Tb$[], Foldable[Ta]) -> Tb$[]
concatMap = concat..map  # type: ignore



## Building lists:

### Scans:
def scanl(func: (Ta, Tb) -> Ta, init: Ta, xs: Tb$[]) -> Ta$[] =
    scan(func, xs, init)

scanl1: ((Ta, Ta) -> Ta, Ta$[]) -> Ta$[]
scanl1 = scan

def scanr(func: (Ta, Tb) -> Ta, init: Ta, xs: Tb[]) -> Ta$[] =
    scan(func, reversed(xs), init)$[::-1]

def scanr1(func: (Ta, Ta) -> Ta, xs: Ta[]) -> Ta$[] =
    scan(func, reversed(xs))$[::-1]

### Infinite lists:
@recursive_iterator
def iterate(func: Ta -> Ta, x: Ta) -> Ta$[] =
    [x] :: iterate(func, func(x))

@recursive_iterator
def repeat(x: Ta) -> Ta$[] =
    [x] :: repeat(x)

def replicate(n: int, x: Ta) -> Ta$[] =
    repeat(x)$[:n]

if TYPE_CHECKING:
    def cycle(xs: Ta$[]) -> Ta$[] =
        ...  # type: ignore
else:
    @recursive_iterator
    def cycle(xs if len(xs) > 0) =
        xs :: cycle(xs)



## Sublists:
def take(n: int, xs: Ta$[]) -> Ta$[] =
    xs$[:n]

def drop(n: int, xs: Ta$[]) -> Ta$[] =
    xs$[n:]

def splitAt(n: int, xs: Ta$[]) -> T.Tuple[Ta$[], Ta$[]] =
    reit = reiterable(xs)
    reit$[:n], reit$[n:]

takeWhile: (Ta -> bool, Ta$[]) -> Ta$[]
takeWhile = takewhile

dropWhile: (Ta -> bool, Ta$[]) -> Ta$[]
dropWhile = dropwhile

if TYPE_CHECKING:
    def span(cond: Ta -> bool, xs: Ta[]) -> T.Tuple[Ta[], Ta[]] =
        ...  # type: ignore
else:
    def span(_, []) = ([], [])

    @addpattern(span)
    def span(cond, [x] + xs if cond(x)) =
        ys, zs = span(cond, xs)
        ([x] + ys, zs)

    @addpattern(span)
    def span(cond, xs) =
        ([], xs)

def break_(cond: Ta -> bool, xs: Ta[]) -> Ta[] =
    """break_ = break"""
    span((not)..cond, xs)



## Searching lists:
def notElem(e: Ta, xs: Ta[]) -> bool =
    e not in xs

def lookup(key: Ta, assocs: T.Tuple[Ta, Tb]$[]) -> Maybe:
    try:
        return (
            assocs
            |> dropwhile$(pair -> pair[0] != key)
            |> .$[0]
            |> .[1]
            |> Just
        )
    except StopIteration:
        return nothing



## Zipping and unzipping lists:
zip: (Ta$[], Tb$[]) -> T.Tuple[Ta, Tb]$[]
zip = _zip

zip3: (Ta$[], Tb$[], Tc$[]) -> T.Tuple[Ta, Tb, Tc]$[]
zip3 = _zip

def zipWith(func: (Ta, Tb) -> Tc, xs1: Ta$[], xs2: Tb$[]) -> Tc$[] =
    starmap(func, zip(xs1, xs2))

def zipWith3(func: (Ta, Tb, Tc) -> Td, xs1: Ta$[], xs2: Tb$[], xs3: Tc$[]) -> Td$[] =
    starmap(func, _zip(xs1, xs2, xs3))

def unzip(xs: T.Tuple[Ta, Tb]$[]) -> T.Tuple[Ta[], Tb[]] =
    _zip(*xs) |> map$(list) |> tuple  # type: ignore

unzip3: T.Tuple[Ta, Tb, Tc]$[] -> T.Tuple[Ta[], Tb[], Tc[]]
unzip3 = unzip  # type: ignore



## Functions on strings:
lines: str -> str[]
lines = .splitlines()  # type: ignore

words: str -> str[]
words = .split()  # type: ignore

def unlines(strs: str[]) -> str =
    "".join(s + "\n" for s in strs)

unwords: str[] -> str
unwords = " ".join




# Converting to and from String:

## Converting to String:
show: Ta -> str
show = repr




# Basic input and output:

## Simple I/O operations:

### Output functions:
putStr: str -> None
putStr = print$(end="")

putChar: Char -> None
putChar = putStr

putStrLn: str -> None
putStrLn = print


### Input functions:
getChar: () -> str
getChar = sys.stdin.read$(1)

getLine: () -> str
getLine = input

getContents: () -> str
getContents = sys.stdin.read

def interact(func: str -> str) -> None:
    while True:
        input() |> func |> print


### Files:
FilePath = T.NewType("FilePath", str)

def readFile(fpath: FilePath) -> str:
    with open(fpath, "r+") as f:
        return f.read()

def writeFile(fpath: FilePath, text: str) -> None:
    with open(fpath, "w+") as f:
        f.write(text)  # type: ignore

def appendFile(fpath: FilePath, text: str) -> None:
    with open(fpath, "a+") as f:
        f.write(text)  # type: ignore



## Exception handling:
IOError: T.Type[Exception]
IOError = _IOError

def ioError() -> None: raise IOError()

def userError(msg: str) -> None: raise IOError(msg)
